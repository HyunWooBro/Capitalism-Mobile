
-	주석을 성실히 달자. 설사 내가 작성한 내용이라도 시간이 지난 후에 보면 거의 기억이 나지 않는 것이 사실이다.
	작성할 당시에는 너무 간단해 보여도 무조건 주석이 있는 것이 훨씬 낫다. 상당히 귀찮은 것이 사실이나 주석의 중요성은 
	아무리 강조해도 지나치지 않은 것 같다.

-	public static final 순서

-	외부 라이브러리가 이 규약을 지키지 않더라도 굳이 수정하지 않는다.

-	mStringID와 같이 축약형은 모두 대문자를 사용한다. glRenderer와 같이 축약형이라고 해도 
	소문자로 시작하면 모두 소문자로 사용한다.

-	패키지의 이름의 경우 패키지 그룹을 가장 잘 나타내는 명칭을 사용한다. 반드시 패키지의 명칭과 똑같은 
	클래스가 필요한 것은 아니다.
	
	=> 모든 클래스의 상위 클래스를 포함하는 경우 'is-a'의 관계를 가진 경우 그 클래스의 
	이름을 사용한다.
	=> 콜랙션과 콜랙션 매니저와 같은 'has-a'의 관계를 가진 경우 구체적인 내용인 콜랙션의 
	이름을 사용한다. 단, 콜랙션 매니저의 명칭이 중요한 의미를 가질 경우 그 명칭을 사용할
	수도 있다.  

-	첫 {를 내려쓰는 것을 좋아했지만 이제는 올려쓰는 것이 나은 것 같다.

-	확장 가능한 코딩을 한다. 

	=> 예전에는 if 나 for 문 다음 명령어가 1줄이라면 {}를 생략했었는데 이제는 생략하지 않도록 한다.
	=> enum 에서 마지막 요소에도 ','를 추가하여 쉽게 확장 가능하게 한다.
	
-	코드를 간략하게 하기 위해 한 줄에 압축하는 것은 디버깅시에는 불리하기 때문에 적절하게 풀어쓰는 것도
	필요하다.

-	float에 대한 값은 정수라도 f를 붙여주어 float라는 것을 명시한다.

-	클래스의 static을 제외한 변수에는 m을 static은 s를 앞에 붙인다. 다만, public 변수에는 m을 붙이지 않는다. 
	그러나 s는 여전히 붙인다.

-	줄이 길어 내릴 때는 탭 2칸만큼 차이가 나게 한다. 단, 긴 내용이 따라오는 경우 탭 1칸으로 한다.

-	메서드 오버로딩이나 비슷한 메서드가 사용되는 경우 가능한 한 다른 메서드에 종속적으로 작성한다.
	생성자에 있어서도 마찬가지이며, 확장 클래스의 생성자에서도 마찬가지다. 

-	줄을 내려 쓸 경우 쉼표는 이전 줄에, 그 외의 모든 연산자는 다음 줄에 둔다.

-	배열의 경우 변수이름 뒤에 -s를 붙인다. List나 Map같은 경우는 변수이름 뒤에 List, Map 등을 붙인다.

-	익명 클래스(e.g. Runnable)에 지역변수를 줄 때의 final 지정은 매개변수에 한다.

-	abstract를 사용하는 경우는 다음과 같다. 우선 abstract을 사용하는 기본적인 목적은 클래스를 확장하여 
	필요한 메서드를 재정의 하도록 강제하는 것이다. 즉, 제 역할을 하기에 부족하기 때문에 인스턴스를 만드는 것을
	막는 것이다.
	
	=> abstract 메서드를 갖는 경우
	=> abstract는 없지만 비어있는 body를 가진 메서드를 가지고 있어 재정의를 해야만 제 역할을 할 수 있는 경우
	=> 생성자의 가시성이 private이나 package이면서 패키지 내에서 또는 nested 클래스에서 확장하는 경우
	=> generic type으로 정의되어 하위 클래스에서 generic type을 구체화하는 경우

-	core에서 utils패키지의 내용은 기본적으로 관련 패키지에서만 주로 사용되는 보조 클래스를
	둔다. 단, core 전체의 utils패키지의 내용은 project에서도 사용될 수 있다.

-	이름이 유사한 여러 변수에 숫자를 매길 때에는 1부터 시작한다. 즉, int x, y, x2, y2가 아니라 
	int x1, y1, x2, y2처럼.

-	변수 선언이나 여러 코드를 나열할 경우 붙여 쓸 것인지 띄어 쓸 것인지에 대한 지침은 상황에 따라 다르다.
	가독성, 관련성 등을 따져서 적절한 선택을 해야한다. 코드를 풀어 쓸 것인지 한번에 묶어서 표현할 것인지도 
	비슷한 주제이다. 

-	클래스 정적상수는 유틸의 개념으로 사용한다.

-	Exception은 다음의 3개를 주로 사용한다. RuntimeException은 너무 추상적이기 때문에 피한다. 한편, 
	Exception 메시지는 영어로 대문자로 시작하고 마침표로 끝낸다.
	
	=> UnsupportedOperationException : 호출해서는 안되는 메서드를 호출할 때
	=> IllegalArgumentException : 매개변수에 문제가 있을 때
	=> IllegalStateException : 객체 상태에 문제가 있을 때(적절치 못한 메서드 호출 등)

-	가시성 선택 기준. 최대한 보수적으로 선택해야 한다.

	=> public : 모든 패키지에서 사용하는 경우 또는 interface 구현할 경우
	=> protected : 하위 클래스에서 재정의할 가능성이 있거나 하위 클래스에서만 접근할 필요가 있는 경우. 추가적으로 
	현재 패키지의 다른 클래스에서도 접근할 수 있다. 만약, 하위 클래스와 관련이 없다면 사용해서는 안된다.
	=> package : 현재 패키지의 다른 클래스에서 사용하는 경우. 자바에는 패키지에 대한 키워드가 없지만 주석으로 표시한다.
	=> private : 클래스 내부적으로만 사용하는 경우

-	내부클래스의 가시성을 private으로 하는 경우 메서드나 멤버의 가시성은 별 차이가 없다. public이든 private이든 
	외부클래스와 내부클래스가 서로 접근할 수 있기 때문이다. 물론 클래스의 가시성이 private이므로 다른 외부 클래스는 
	내부클래스의 메서드나 멤버를 전혀 접근할 수 없다. 내부 클래스가 2개 있을 때도 서로의 private에 접근할 수 
	있고 심지어 내부 클래스를 확장한 sub클래스도 재정의만 못할 뿐이지 super클래스의 private을 접근할 수 있다. 
	이와 같은 경우에는 내부클래스의 메서드나 멤버를 외부클래스에서 접급한다면 public으로, 내부클래스에서만 
	사용된다면 prviate으로 표현하도록 한다. 그럼으로써 사용되는 범위를 한눈에 알 수 있다.

-	변수의 무효값을 지정할 때는 반드시 유효값의 범위를 벗어나야 한다. 일반적으로 무효값은 따로 정적상수로 
	정의하여 사용하는 경우가 많다.
	
	=> x, y좌표 : 일반적으로 x, y좌표는 음의 무한대에서 양의 무한대를 모두 포괄하니 무효값을 지정할 수는 없지만 
	예외적으로 특정 범위에서만 존재하는 것이 확실하다면 무효값을 지정할 수도 있다.
	=> 너비, 높이 : 기본적으로 0에서 양의 무한대까지다. 보통 무효값은 -1을 사용한다. 출력의 경우 너비 또는 높이가 
	0인 경우 실제로는 출력되지 않기 때문에 사실상 실효성이 없는 것으로 보이나 그것이 반드시 무효하다고는 
	볼 수 없다. 초기 상태가 출력을 하지 않는다기 보다는 넓이가 0인 사각영역을 출력하는 것으로 볼 수 있기 
	때문이다. 한편, 너비 또는 높이가 0인 것이 유효하다는 것은 Form의 기본 사이즈의 값 0을 유효하다고 본다는 
	의미이다. 즉, 따로 지정이 없으면 그것을 의도된 선택으로 여기고 사용한다.
	=> 지속시간 : 기본적으로 0에서 양의 무한대까지다. 보통 무효값은 -1을 사용한다.

-	deprecated된 메서드는 보통 UnsupportedOperationException를 호출한다. 간혹 super클래스의 A 메서드가 
	B 메서드를 호출할 때 sub클래스에서 B 메서드를 재정의하여 deprecated되도록 한다면 문제가 발생한다.
	
	=> 어떤 메서드가 sub클래스에서 재정의되어 deprecated될 가능성이 있다면 그 메서드의 호출을 자제해야 한다.
	=> 그럼에도 호출할 필요가 있다면, 그 메서드가 더 상위 클래스에서 유래한 경우 super키워드를 사용한다. 만약 
	같은 클래스에서 유래하여 super키워드를 사용할 수 없다면 protected 메서드를 하나 추가하여 공통된 처리를 
	맡길 수 있다. (오버로딩은 다음을 참조)
	=> 특히 주의해야할 경우는 deprecated를 피하기 위해 super키워드를 사용했는데 그 super 메서드가 오버로딩된 
	다른 메서드를 호출할 때이다. 만약 호출된 메서드가 sub클래스에서 재정의되어 deprecated되었다면 역시 예외가 
	발생하기 때문이다. 앞에서 언급한 것처럼 호출할 오버로딩된 메서드가 더 상위 클래스에서 유래한 것이라면 
	super키워드를 사용할 수 있다. 그렇지 않다면 최종 오버로딩된 메서드를 직접 호출해야 한다. 또는 오버로딩하는 
	메서드가 많거나 sub클래스에서 오버로딩을 유효하게 사용하려면 protected 메서드를 하나 추가하여 공통된 처리를 
	맡길 수 있다. 이 공통된 내용을 처리하는 protected 메서드는 굳이 deprecated할 필요는 없다. 어차피 외부에 공개되지 
	않기 때문이고 유저가 이 메서드를 사용할 수 있는 경우는 재정의를 통해서인데 굳이 그것까지 막을 필요는 없기 
	때문이다. 
	=> deprecated된 메서드는 final을 추가하여 더 이상의 재정의를 막도록 한다.

-	안드로이드처럼 어떤 이벤트에 대한 콜백 메서드의 경우 앞에 on을 붙인다.

	=> Listener라는 명칭으로 끝나는 인터페이스나 클래스의 콜백 메서드는 on을 붙인다.
	=> onSizeChanged, onChildrenChanged, onTextChanged와 같이 특정 속성이 유저에 의해 변경될 때 함께 처리되어야 
	하는 코드를 정의하는 콜백 메서드에 on을 붙인다. 이들 메서드는 일반적으로 내부적으로 정의되고 사용되므로 protected 
	가시성을 갖는다.

-	boolean 타입에 대한 변수 및 get, set 메서드의 명명법은 다음과 같다.

	=> boolean 타입은 다른 타입과는 달리 true와 false만을 의미하는 독특한 개념이기 때문에 변수의 명명법도 조금 다르다. 
	보통의 변수는 명사를 사용하지만 boolean은 일반적으로 형용사를 사용할 뿐만 아니라 동사까지도 가능하다.
	=> set 메서드는 다른 타입과 동일하게 set을 앞에 추가하는게 보통이지만 get 메서드는 get이 아니라 is를 앞에 추가하는 
	것이 보통이며 변수의 이름에 동사가 들어간 경우라면 앞에 will을 붙이도록 한다.
	=> 한편, boolean을 리턴 타입으로 갖는 메서드의 명칭도 위의 경우를 응용할 수 있다. is나 will로 시작할 수도 있지만 
	때에 따라 can이나 should 등의 조동사도 가능하다. 또는 contains나 hasChildren처럼 결과가 참인지 거짓인지를 알아내는 
	것이 메서드의 주목적인 경우에 3인칭 단수형의 동사를 사용할 수 있다.
	
-	부득이하게 기존의 존재하는 메서드와 같은 이름을 사용할 수밖에 없다면 메서드명 앞에 _(underscore) 기호를 붙일 수 
	있다.
	
-	주 메서드에서 사용되는 보조 메서드의 경우 배치하는 위치는 주 메서드에서 처리되는 위치에 따른다. 주 메서드에서 
	precondition 등을 처리하는 것과 같이 먼저 처리되는 경우라면 주 메서드 위에 배치하고, 주 메서드의 대부분의 처리가 
	끝난 후에 정리 하는 상황이나 핵심 과정을 처리하는 경우라면 아래에 배치한다. 이것은 절대적인 것이 아니라 상대적인 
	것이므로 상황에 따라 적절하게 배치해야 한다.

-	제공하는 타입은 가시성선택의 기준처럼 최대한 보수적으로 최소한의 정보만을 제공해야 한다. 

	=> 내부적으로 ArrayList를 사용하더라도 구체적인 구현과는 상관없이 List 인터페이스의 메서드만을 사용한다면 
	List 타입을 사용하도록 한다.
	
-	변수의 영역도 최대한 보수적으로 제공해야 한다.

	=> 이름없는 클래스의 변수로만 사용된다면 굳이 외부 클래스에 변수를 보관하기 보다는 이름없는 클래스의 변수로 
	선언해야 한다.
	
-	continue 또는 break에 레이블을 사용할 경우 목표가 되는 레이블은 앞에 빈 공간이 없도록 왼쪽에 밀착해서 작성한다.

-	else if의 경우 else 때문에 if문과 정렬이 깔끔하지 않아 구별이 쉽지 않을 수 있기 때문에 else나 else if위의 빈칸을 둔다.

-	클래스의 변수를 선언하는 순서는 다음과 같다.

	=> enum의 경우 가장 상단에 위치한다.
	=> static의 경우 enum 다음에 위치한다.
	=> 내부 클래스의 경우 가장 하단에 위치한다.
	=> 가시성과는 관련 없다.

-	가상 클래스(또는 인터페이스)를 또 다른 가상 클래스가 확장(또는 구현)하는 경우 상위 가상 메서드를 구체화 하지 
	않더라도 abstract 등으로 포함하고 있는 것을 분명하게 표현할 수 있다. 이런 경우 @Override를 붙여준다.
	
-	static final은 파이값(3.14..)과 같은 상수 값이나 객체의 재생성을 방지하기 위한 임시 변수에 주로 사용한다.
	
-	기본적으로 배열은 크기가 정적으로 정해진 경우에 사용하고 ArrayList는 동적인 경우에 사용한다.
	
	 